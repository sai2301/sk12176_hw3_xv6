# HW3 — Priority Scheduling and `nice` System Call

**Name:** Sai Krishna Kommineni  
**NetID:** sk12176  

---

## Overview
This assignment extends the xv6 operating system to support **priority-based scheduling** and a new `nice` system call that allows processes to adjust their own or another process’s priority.  
Additionally, an **aging mechanism** (extra credit) was implemented to ensure fair CPU sharing and prevent starvation of lower-priority processes.

---

## Implemented Features

### 1. Priority Scheduling
- Added fields to each process:
  - `nice` — user-assigned value (0–4)
  - `base_priority` — derived from `nice`
  - `eff_priority` — effective priority used by the scheduler
  - `wait_ticks` — counter for aging
- The scheduler selects the process with the **lowest `eff_priority`** (0 = highest priority).
- Tie-breaking is done by **PID** (lower PID wins).

### 2. `nice` System Call
- **Prototype:** `int nice(int pid, int value)`
- **Usage:**
  - `nice <value>` → change the current process’s priority.
  - `nice <pid> <value>` → change another process’s priority.
- Returns the **previous nice value** on success, `-1` on error.
- Handles both **invalid PIDs** and **out-of-range values (0–4)** gracefully.

### 3. Aging (Extra Credit)
- Implemented aging to gradually boost waiting processes.
- After every `AGING_INTERVAL = 50` ticks, each RUNNABLE process’s `eff_priority` improves (decreases numerically).
- Prevents starvation by ensuring long-waiting processes eventually run.

---

## Modified Files

| File | Description |
|------|--------------|
| `proc.h` | Added new fields for priority and aging. |
| `proc.c` | Implemented scheduling logic, aging, and helper `setnice()`. |
| `sysproc.c` | Added kernel handler for `nice` syscall. |
| `syscall.c`, `syscall.h`, `usys.S`, `user.h` | Registered the new syscall. |
| `nice.c` | New user-space program to modify process priorities. |
| `Makefile` | Added `_nice`, `_test1`, `_test2`, `_test3` to `UPROGS`. |

---

## How to Build and Run

```bash
make clean
make CPUS=1 qemu-nox
Then, in the xv6 shell:

bash
Copy code
test1
test2
test3
Manual Verification
bash
Copy code
burn &; burn &; burn &
ps
nice <pid> <value>
Expected Behavior
Processes with lower nice values (higher priority) receive more CPU time.

Invalid PIDs and out-of-range nice values are safely rejected.

Long-waiting processes automatically improve in priority due to aging.

All provided test programs (test1, test2, test3) pass successfully.

Notes
Use CPUS=1 for deterministic results.

Use Ctrl+P to print process states and priorities.

The design preserves all original xv6 functionality while adding fair priority scheduling.